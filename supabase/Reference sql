/* ---------- Helpful indexes for fast counts ---------- */
CREATE INDEX IF NOT EXISTS idx_projects_org   ON public.projects   (organization_id);
CREATE INDEX IF NOT EXISTS idx_resources_org  ON public.resources  (organization_id);
CREATE INDEX IF NOT EXISTS idx_holes_org      ON public.holes      (organization_id);
-- assets already has idx_assets_org in your schema, keep it if present
CREATE INDEX IF NOT EXISTS idx_vendors_org    ON public.vendors    (organization_id);
CREATE INDEX IF NOT EXISTS idx_plods_org      ON public.plods      (organization_id);

/* ---------- Core quota enforcement function ---------- */
CREATE OR REPLACE FUNCTION public.enforce_org_row_quota(
  p_organization_id uuid,
  p_limit_key text,
  p_table regclass
)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  v_limits jsonb;
  v_limit int;
  v_count bigint;
BEGIN
  IF p_organization_id IS NULL THEN
    RAISE EXCEPTION 'organization_id is required';
  END IF;

  -- Serialize per-org creates to avoid race conditions (2 users inserting at once)
  PERFORM 1
  FROM public.organizations o
  WHERE o.id = p_organization_id
  FOR UPDATE;

  v_limits := public.get_org_plan_limits(p_organization_id);
  v_limit := NULLIF((v_limits ->> p_limit_key), '')::int;

  -- If something is misconfigured, fail fast (hard limits)
  IF v_limit IS NULL THEN
    RAISE EXCEPTION 'No subscription limit configured for "%" (org=%)', p_limit_key, p_organization_id
      USING ERRCODE = 'P0001';
  END IF;

  EXECUTE format('SELECT count(*) FROM %s WHERE organization_id = $1', p_table)
    INTO v_count
    USING p_organization_id;

  IF v_count >= v_limit THEN
    RAISE EXCEPTION 'Quota exceeded for %: %/%', p_limit_key, v_count, v_limit
      USING ERRCODE = 'P0001';
  END IF;
END;
$$;

/* ---------- Generic trigger: enforce quota on INSERT ---------- */
CREATE OR REPLACE FUNCTION public.trg_enforce_org_quota_on_insert()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  -- TG_ARGV[0] = limits key (e.g. 'projects')
  PERFORM public.enforce_org_row_quota(NEW.organization_id, TG_ARGV[0], TG_RELID::regclass);
  RETURN NEW;
END;
$$;

/* ---------- Generic trigger: prevent changing organization_id (no bypass) ---------- */
CREATE OR REPLACE FUNCTION public.trg_prevent_org_change()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.organization_id IS DISTINCT FROM OLD.organization_id THEN
    RAISE EXCEPTION 'organization_id cannot be changed' USING ERRCODE = 'P0001';
  END IF;
  RETURN NEW;
END;
$$;

/* ---------- Holes special-case: allow deriving org from project_id if missing ---------- */
CREATE OR REPLACE FUNCTION public.trg_holes_set_org_and_enforce_quota()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_org uuid;
BEGIN
  IF NEW.organization_id IS NULL AND NEW.project_id IS NOT NULL THEN
    SELECT p.organization_id INTO v_org
    FROM public.projects p
    WHERE p.id = NEW.project_id;

    NEW.organization_id := v_org;
  END IF;

  IF NEW.organization_id IS NULL THEN
    RAISE EXCEPTION 'holes.organization_id is required (or provide project_id to infer it)'
      USING ERRCODE = 'P0001';
  END IF;

  PERFORM public.enforce_org_row_quota(NEW.organization_id, 'holes', 'public.holes'::regclass);
  RETURN NEW;
END;
$$;

/* ---------- Attach triggers to each table ---------- */
-- projects
DROP TRIGGER IF EXISTS trg_projects_quota_insert ON public.projects;
CREATE TRIGGER trg_projects_quota_insert
BEFORE INSERT ON public.projects
FOR EACH ROW
EXECUTE FUNCTION public.trg_enforce_org_quota_on_insert('projects');

DROP TRIGGER IF EXISTS trg_projects_prevent_org_change ON public.projects;
CREATE TRIGGER trg_projects_prevent_org_change
BEFORE UPDATE ON public.projects
FOR EACH ROW
EXECUTE FUNCTION public.trg_prevent_org_change();

-- resources
DROP TRIGGER IF EXISTS trg_resources_quota_insert ON public.resources;
CREATE TRIGGER trg_resources_quota_insert
BEFORE INSERT ON public.resources
FOR EACH ROW
EXECUTE FUNCTION public.trg_enforce_org_quota_on_insert('resources');

DROP TRIGGER IF EXISTS trg_resources_prevent_org_change ON public.resources;
CREATE TRIGGER trg_resources_prevent_org_change
BEFORE UPDATE ON public.resources
FOR EACH ROW
EXECUTE FUNCTION public.trg_prevent_org_change();

-- assets
DROP TRIGGER IF EXISTS trg_assets_quota_insert ON public.assets;
CREATE TRIGGER trg_assets_quota_insert
BEFORE INSERT ON public.assets
FOR EACH ROW
EXECUTE FUNCTION public.trg_enforce_org_quota_on_insert('assets');

DROP TRIGGER IF EXISTS trg_assets_prevent_org_change ON public.assets;
CREATE TRIGGER trg_assets_prevent_org_change
BEFORE UPDATE ON public.assets
FOR EACH ROW
EXECUTE FUNCTION public.trg_prevent_org_change();

-- vendors
DROP TRIGGER IF EXISTS trg_vendors_quota_insert ON public.vendors;
CREATE TRIGGER trg_vendors_quota_insert
BEFORE INSERT ON public.vendors
FOR EACH ROW
EXECUTE FUNCTION public.trg_enforce_org_quota_on_insert('vendors');

DROP TRIGGER IF EXISTS trg_vendors_prevent_org_change ON public.vendors;
CREATE TRIGGER trg_vendors_prevent_org_change
BEFORE UPDATE ON public.vendors
FOR EACH ROW
EXECUTE FUNCTION public.trg_prevent_org_change();

-- plods
DROP TRIGGER IF EXISTS trg_plods_quota_insert ON public.plods;
CREATE TRIGGER trg_plods_quota_insert
BEFORE INSERT ON public.plods
FOR EACH ROW
EXECUTE FUNCTION public.trg_enforce_org_quota_on_insert('plods');

DROP TRIGGER IF EXISTS trg_plods_prevent_org_change ON public.plods;
CREATE TRIGGER trg_plods_prevent_org_change
BEFORE UPDATE ON public.plods
FOR EACH ROW
EXECUTE FUNCTION public.trg_prevent_org_change();

-- holes (special)
DROP TRIGGER IF EXISTS trg_holes_quota_insert ON public.holes;
CREATE TRIGGER trg_holes_quota_insert
BEFORE INSERT ON public.holes
FOR EACH ROW
EXECUTE FUNCTION public.trg_holes_set_org_and_enforce_quota();

DROP TRIGGER IF EXISTS trg_holes_prevent_org_change ON public.holes;
CREATE TRIGGER trg_holes_prevent_org_change
BEFORE UPDATE ON public.holes
FOR EACH ROW
EXECUTE FUNCTION public.trg_prevent_org_change();